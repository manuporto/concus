1. a
2. a
3. **exit():** Cuando un proceso ejecuta esta system call el kernel realiza una serie de acciones previo a la finalizacion formal 
del proceso:
   1. Ignora todas las señales ya que en esta instancia no hay razón para manejarlas.
   2. Si el proceso finalizando es un _process group leader_ el kernel envia una señal de hangup a todos los procesos del grupo.
   3. Se liberan todos los recursos de memoria creada por el proceso a excepcion del slot del proceso en la tabla de procesos 
   (solamente en caso de que sea un proceso hijo, en donde dicha información permanecerá hasta que el proceso padre realice 
   un `wait()`).
   4. Se registran datos de runtime del proceso (user id, CPU, I/O, etc).
   5. El proceso entra en estado zombie.
   6. Se realiza un context-switch para que el scheduler pueda ejecutar otro proceso. El kernel nunca vuelve a designar para
   ejecución a un proceso que esta en estado zombie.
   
   **wait():** Suponiendo que el proceso que realiza estas system calls tiene procesos hijos (en caso contrario 
   se devuelve un error), ocurre lo siguiente:
   Si el proceso tiene algún hijo en estado zombie, extrae el PID y el codigo de returno del hijo. En caso de que ninguno de sus
   hijos se encuentre en estado zombie, el proceso padre se bloquea hasta que alguno de sus hijos entre en dicho estado y le envíe 
   la señal _death of child_ (esta señal es la unica a la que el proceso padre responde cuando se bloquea con un `wait()`).
   
   **waitpid():** El procedimiento es analogo a `wait()` con la diferencia que aqui se espera por un proceso en particular en vez 
   de por cualquiera.
